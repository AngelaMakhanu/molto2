#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Token2 Molto2 USB Config Tool v0.1.2
# Copyright 2023 Token2 Sarl
# Fair Source License, version 0.9 
# Licensed to : gauthier.hubert@flowdesk.co
from smartcard.System import readers
from smartcard.util import toHexString
from binascii import hexlify, unhexlify
from datetime import datetime
import hashlib
import base64
import binascii
from sm4 import SM4Key
from time import time as timestamp
from time import sleep as pause
import argparse, sys


parser=argparse.ArgumentParser()
parser.add_argument("--key", help="Customer key in hex format. Default will be used if not supplied.")
parser.add_argument("--keyascii", help="Customer key in ascii format. Default will be used if not supplied.")
parser.add_argument("--profile", help="Profile number, from 0 to 49 (Molto2) or from 0 to 99 (Molto2 v2)")
parser.add_argument("--title", help="Profile title, 12 chars max")
parser.add_argument("--seed", help="Seed to write, in hex format")
parser.add_argument("--seedbase32", help="Seed to write, in base32 format")
parser.add_argument("--setkey", help="Set the new customer key, providing the key  in hex. Please note that setting new key requires confirmation on the device (physical button press)")
parser.add_argument("--setkeyascii", help="Set the new customer key, providing key in ascii. Please note that setting new key requires confirmation on the device (physical button press)")
parser.add_argument("--config", help="If config parameter is set, the config parameters become required." , action='store_true')
parser.add_argument("--synctime", help="Will update time on the given profile." , action='store_true')
parser.add_argument("--synctimeall", help="Will update time on all profiles." , action='store_true')
parser.add_argument("--display_timeout", help="mandatory if --config is set as 1. Possible values 0=15s, 1=30s, 2=60s, 3=120s")
parser.add_argument("--algorithm", help="mandatory if --config is set as 1. Possible values 1=SHA1 HMAC or 2=SHA256 HMAC hashing algorithm")
parser.add_argument("--timestep", help="mandatory if --config is set as 1. Possible values 1=30 seconds   or 2= 60 seconds")
parser.add_argument("--otpdigits", help="Number of digits generated by TOTP algorithm. Possible values 4, 6, 8 or 10. Default is 6.")
parser.add_argument("--factoryreset", help="Resets the device to factory setting and clear all data. Please note this requires confirmation on the device (physical button press)", action='store_true')
parser.add_argument("--lock", help="Lock device screen (only for v2.1 and higher)", action='store_true')
parser.add_argument("--unlock", help="Unlock device screen (only for v2.1 and higher)", action='store_true')



args=parser.parse_args()

reader = next((reader for reader in readers()
    if "TOKEN2".lower() in reader.name.lower() ), None)
    

connection = reader.createConnection()
connection.connect()



print (f"==========================================================")
print (f" [i] TOKEN2 Molto2 USB Config Tool, Python version, v0.2")
print (f"                                         (c) TOKEN2 Sarl ")
print (f"==========================================================")

if  args.factoryreset ==  True:
 SELECT = [0x80, 0x56, 0x00, 0x00, 0x00]
 data, sw1, sw2 = connection.transmit( SELECT  )
 print(f"[i] Factory reset")
 print(f"[i] Resetting the device to factory settings. Please note that this will delete all profiles and set the customer key to default")
 print(f"[!] PLEASE CONFIRM THE CHANGE ON THE DEVICE BY PRESSING the ▲ KEY!")
 exit()


if args.seed !=None and args.seedbase32 !=None:
 print("[!] Seed both in hex and base32 supplied, please provide only one format")
 exit()

if args.seed ==None and args.seedbase32 !=None:
 seed=base64.b16encode(base64.b32decode(str(args.seedbase32))).decode("utf-8") 
else:
 seed=args.seed
 
#Check Profile title
if  args.title != None:
 if len(args.title)>12:
  print("[!] Profile title cannot be longer than 12 symbols")
  exit()


#Default customer key
if  args.key == None and args.keyascii == None:
 customer_key = "544F4B454E324D4F4C544F312D4B4559"
 print('[!] Note: No customer key was provided, default customer key will be used')
else:
 if  args.key != None:
  customer_key =  args.key
 if  args.keyascii != None:
  customer_key = args.keyascii.encode('utf-8').hex().upper()

customer_key_hex=customer_key
customer_key = unhexlify(customer_key)

if args.profile != None:
 profile_number = int(args.profile)
 prof = hex(profile_number)[2:].zfill(2)
else:
 profile_number = 0x00
 prof = "00"

def calc_mac(key,message: bytes) -> bytes:

  message_with_padding = message
  if len(message) % 16 != 0:
   message_with_padding += b'\x80' + \
    b'\x00' * (15 - (len(message) % 16))

  sm4 = SM4Key(key)
  mac = sm4.encrypt(message_with_padding, initial=b'\0'*16)
  mac = mac[-16:-16+4]  # MAC is the first 4 bytes (of the last block).

  return mac









#Get Serial Number
SELECT = [0x80, 0x41, 0x00, 0x00, 0x00]
data, sw1, sw2 = connection.transmit( SELECT  )
info = bytes(data)
serial_len = int(info[3])
serial = info[4:4+serial_len].decode("utf-8")
time_offset = 4 + serial_len + 2
time_len = 4
time = int.from_bytes(info[time_offset:time_offset+time_len], "big")
time = datetime.utcfromtimestamp(time).strftime("%Y-%m-%d %H:%M:%S")
print (f"[+] device serial number: { serial }")
print ( f"[+] device system time (UTC): {time}")

if args.synctimeall == None:
 if (args.config == True or args.seed != None or args.title != None or args.synctime != None)   and args.profile == None:
  print("[x] No valid profile number is provided. We dont know which profile to use. Please supply profile number (0-49 for Molto2 and 0-99 for Molto2v2)")
  exit()
else:
 if args.profile != None:
  print(f"[i] Selected profile: [#{args.profile}]") 

SELECT = [0x80, 0x4b, 0x08, 0x00, 0x00]
data, sw1, sw2 = connection.transmit( SELECT  )
challenge = bytes(data)
challenge = challenge + b'\x00' * 8
key_sha1=hashlib.sha1(customer_key).digest()[:16]
sm4 = SM4Key(key_sha1)
response_raw = sm4.encrypt(challenge)
cla = 0x80
ins = 0xCE
p1 = 0x00
p2 = 0x00
lc = 0x10 
apdu = [cla, ins, p1, p2, lc]
apdu.extend(response_raw)
data, sw1, sw2 = connection.transmit(apdu  )
auth = bytes(data)
if sw1 == 99:
 print(f"[-] Authentication failure, number of attempts left: {sw2}")
 print(f"[-] Make sure you entered the correct access key / password")
 exit()
if sw1 == 144:
 print(f"[+] Authentication successful")



#Lock 

if  args.lock ==  True:
 print("[i] Locking screen device")
 cla = 0x80
 ins = 0xD8
 p1 = 0x0C
 p2 = 0x02

 lc = 0x00
 apdu = [cla, ins, p1, p2,lc]

 data, sw1, sw2 = connection.transmit(apdu  )
 
 if sw1 == 144:
  print(f"[+] Device screen locked")
  
 
#Unlock 

if  args.unlock ==  True:
 print("[i] Locking screen device")
 cla = 0x80
 ins = 0xD8
 p1 = 0x0C
 p2 = 0x02
 p3=  0x01
 lc = 0x00
 apdu = [cla, ins, p1, p2,p3,lc]

 data, sw1, sw2 = connection.transmit(apdu  )
 
 if sw1 == 144:
  print(f"[+] Device screen locked")
  
  
 
#start setting seed 
if  seed != None:
 if (len(seed) % 2 != 0):
  print("[!] Seed hex-string has an invalid length (not multiple of 2 chars.)")
  exit()
 int(seed, 16)  # 
 if len(seed) > 63*2:
  print("[!] Seed is too long (more than 63 bytes)")
  exit()

if  seed != None:
 print(f"[i] Writing seed: '{seed.upper()}'  for profile [#{args.profile}] ")
 seed = unhexlify(seed)
 if len(seed) % 16 != 0:
  seed += b'\x80' + b'\x00' * (15 - (len(seed) % 16))
  
 sm4 = SM4Key(key_sha1)
 enc_seed = sm4.encrypt(seed)
 mac_seed=str(len(enc_seed))
 add_len=hex(int(mac_seed))[2:].zfill(2)
 mac_packet = unhexlify("80C501"+prof+add_len) + enc_seed
 mac = calc_mac(key_sha1,mac_packet)
 cla = 0x84
 ins = 0xC5
 p1 = 0x01
 p2 = profile_number
 data = enc_seed + mac
 lc = len(data)
 apdu = [cla, ins, p1, p2,lc]
 apdu.extend(data)
 data, sw1, sw2 = connection.transmit(apdu  )
 auth = bytes(data)
 if sw1 == 144:
  print(f"[+] Seed was set successfully")

if args.title !=None: 
 print(f"[i] Setting profile title as '{args.title}' for profile [#{args.profile}]")
 cla = 0x84
 ins = 0xD5
 p1 = 0x00
 p2 = profile_number
 lc = 0x14
 sm4 = SM4Key(key_sha1)
 title =  args.title.encode("utf-8") 
 title = binascii.hexlify(title)
 title=unhexlify(title)
 if len(title) % 16 != 0:
  title += b'\x80' + b'\x00' * (15 - (len(title) % 16))
 #print  (f"Setting title {title}") 
 enc_title= sm4.encrypt(title)
 mac_packet = unhexlify("80D500"+prof+"10") + enc_title
 mac = calc_mac(key_sha1,mac_packet)
 data = enc_title + mac
 apdu = [cla, ins, p1, p2,lc]
 apdu.extend(data)
 
 data, sw1, sw2 = connection.transmit(apdu  )
 if sw1 == 144:
  print(f"[+] Title was set successfully")


if args.config == True:
 print("[i] Setting configuration") 
 #Get current time
 time = int(timestamp())

 display_timeout = int(args.display_timeout or 99)
 if display_timeout == None or display_timeout > 3 or display_timeout < 0:
  print("[!] Incorrect display_timeout value (must be 0-3).")
  exit()

 hmac_method = int(args.algorithm or 99)
 if hmac_method == None or hmac_method > 2 or hmac_method < 1:
  print("[!] Incorrect algorithm (must be 1 for sha1 or 2 for sha256)")
  exit()

 time_step = int(args.timestep or 99)
 if time_step > 2 or time_step < 1:
  print("Incorrect timestep value provided (must be 1 for 30s or 2 for 60s).")
  exit()

 time = hex(time)[2:].zfill(8)
 display_timeout = "0" + str(display_timeout)
 hmac_method = "0" + str(hmac_method)

 time_step = "1E" if time_step == 1 else "3C"
 
 if args.otpdigits == None:
  otp_digits = 6
 else: 
  otp_digits = args.otpdigits

 otp_digits_hex = "06"
 if otp_digits == "4":
  otp_digits_hex = "04"
 if otp_digits == "6": 
  otp_digits_hex = "06"
 if otp_digits == "8": 
  otp_digits_hex = "08"
 if otp_digits == "10": 
  otp_digits_hex = "0A"
  
 # Construct command data
 data = ("8114")# TLV_TAG_SYS_CONFG header and length
 data = data + "1F01" + display_timeout  # TLV_TAG_SYSCLOSE_TIMEOUT header and length
 data = data +  "0F04" + time # TLV_TAG_UTC_TIME header and length
 data = data +  "8609" # TLV_TAG_TOTP_PARAM header and length
 data = data +    "0A01" + hmac_method # TLV_TAG_TOTP_HMAC header and length
 data = data +  "0B01" + otp_digits_hex # TLV_TAG_OCRA_TRUNC_LEN header and length
 data = data +  "0D01" + time_step # TLV_TAG_TOTP_TIME_STEP header and length
 
 
 
 data = unhexlify(data)
 
 mac_d=str(len(data))
 d_len=hex(int(mac_d))[2:].zfill(2)
 
 mac_packet = unhexlify("80D401"+prof+d_len) + data
 mac = calc_mac(key_sha1,mac_packet)
 
 cla = 0x84
 ins = 0xD4
 p1 = 0x01
 p2 = profile_number
 data = data + mac
 lc = len(data)
 
 apdu = [cla, ins, p1, p2, lc ]
 apdu.extend(data)
 

 data, sw1, sw2 = connection.transmit(apdu  )
 
 
 if sw1 == 144:
  print(f"[+] Config was set successfully for profile [#{args.profile}]")
 else: 
  print(f"[!] Config failed for  [#{args.profile}]")

 
hexkey = ""

#set new customer key
if args.setkey !=None:
 hexkey = args.setkey.upper()
 print(f"[i] Setting new customer key hex value as: {hexkey}")
 
 
 
if args.setkeyascii !=None:
 hexkey = args.setkeyascii.encode('utf-8').hex().upper()
 print(f"[i] Setting new customer key (ASCII):  {args.setkeyascii}")
 print(f"[i] New customer key hex value is: {hexkey}")
 
 
if hexkey !="":
 #set customer key
 print(f"[i] Setting new key ")
 newkey_sha1=hashlib.sha1(unhexlify(hexkey)).digest()[:16]
 encData=unhexlify("00")+newkey_sha1+unhexlify("800000000000000000000000000000")
 sm4 = SM4Key(key_sha1)
 SM4encData = sm4.encrypt(encData)
 mac_packet = unhexlify("80d7000020") + SM4encData
 mac = calc_mac(key_sha1,mac_packet)
 cla = 0x84
 ins = 0xD7
 p1 = 0x00
 p2 = 0x00
 lc = 0x24
 data = SM4encData + mac
 apdu = [cla, ins, p1, p2,lc]
 apdu.extend(data)
 data, sw1, sw2 = connection.transmit(apdu  )
 if sw1 == 144:
  print(f"[+] New customer key request was successfully sent to the device.")
  print(f"[!] Complete the operation by confirming on the device.")
  print(f"[!] You need to press the up arrow (▲) button for confirmation")
 
 

 
  
if args.synctime == True:
 print(f"[i] Syncing time on profile [#{args.profile}]") 
 #Get current time
 time = int(timestamp())



 time = hex(time)[2:].zfill(8)
  
 # Construct command data
 data = ("8106")# TLV_TAG_SYS_CONFG header and length
 data = data +  "0F04" + time # TLV_TAG_UTC_TIME header and length
 
  
 data = unhexlify(data)
 
 mac_d=str(len(data))
 d_len=hex(int(mac_d))[2:].zfill(2)
 
 mac_packet = unhexlify("80D401"+prof+d_len) + data
 mac = calc_mac(key_sha1,mac_packet)
 
 cla = 0x84
 ins = 0xD4
 p1 = 0x01
 p2 = profile_number
 data = data + mac
 lc = len(data)
 
 apdu = [cla, ins, p1, p2, lc ]
 apdu.extend(data)
 

 data, sw1, sw2 = connection.transmit(apdu  )
 if sw1 == 144:
  print(f"[+] Time was set successfully for profile [#{args.profile}]")
 else: 
  print(f"[!] Time sync failed for  [#{args.profile}]")
  
if args.synctimeall == True:
 print(f"[i] Syncing time on all profiles") 
 
 for profnumber in range(100):
  profile_number = int(profnumber)
  prof = hex(profile_number)[2:].zfill(2)
  print(f"Syncing time for profile #{profile_number}")
 #Get current time
  time = int(timestamp())
  time = hex(time)[2:].zfill(8)
   # Construct command data
  data = ("8106")# TLV_TAG_SYS_CONFG header and length
  data = data +  "0F04" + time # TLV_TAG_UTC_TIME header and length
  data = unhexlify(data)
  mac_d=str(len(data))
  d_len=hex(int(mac_d))[2:].zfill(2)
  mac_packet = unhexlify("80D401"+prof+d_len) + data
  mac = calc_mac(key_sha1,mac_packet)
  cla = 0x84
  ins = 0xD4
  p1 = 0x01
  p2 = profile_number
  data = data + mac
  lc = len(data)
  apdu = [cla, ins, p1, p2, lc ]
  apdu.extend(data)
  data, sw1, sw2 = connection.transmit(apdu  )

  if sw1 == 144:
    print(f"[+] Time was set successfully for profile [#{profile_number}]")
  else: 
    print(f"[!] Time sync failed for  [#{profile_number}]")
    
